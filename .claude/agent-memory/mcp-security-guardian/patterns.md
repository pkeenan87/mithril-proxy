# MCP Security Patterns — Extended Notes

## SSE Proxy Security

### Line-level SSE validation
The SSE spec (RFC-like) defines exactly five field prefixes: `data:`, `event:`, `id:`,
`retry:`, and `:` (comment). Any line from upstream that does not match one of these MUST
be dropped, not forwarded. Forwarding arbitrary lines enables:
- Injecting secondary `event:` directives to confuse the client SSE parser
- Embedding prompt-injection text inside comment lines (`: SYSTEM: ignore previous...`)
- Injecting `retry:` to manipulate client reconnect timing (DoS vector)

Safe pattern:
```python
ALLOWED_SSE_PREFIXES = ("data:", "event:", "id:", "retry:", ":")
if not any(raw_line.startswith(p) for p in ALLOWED_SSE_PREFIXES) and raw_line != "":
    continue  # drop unknown fields silently
```

### Endpoint URL validation
When an SSE `endpoint` event carries an absolute URL, validate it against the expected
upstream base before storing:
```python
from urllib.parse import urlparse
def _is_same_origin(url: str, base: str) -> bool:
    p, b = urlparse(url), urlparse(base)
    return p.scheme == b.scheme and p.netloc == b.netloc
```
If the URL is not same-origin, reject and close the stream.

## Session Map Security

### Session ID format enforcement
Always validate session IDs extracted from upstream before storing:
```python
_SESSION_ID_PATTERN = re.compile(r'^[A-Za-z0-9_\-]{8,128}$')
if not _SESSION_ID_PATTERN.match(session_id):
    raise ValueError(f"Invalid session ID format: {session_id!r}")
```

### Map size cap
Unbounded in-process session maps are a DoS vector. Add a cap:
```python
MAX_SESSIONS = 1000
if len(_session_map) >= MAX_SESSIONS:
    raise RuntimeError("Session map at capacity")
```

## Header Forwarding

### Request direction — skip list
Minimum skip set going upstream:
`{"host", "content-length", "transfer-encoding", "connection", "keep-alive",
  "x-forwarded-for", "x-real-ip", "x-forwarded-host", "x-forwarded-proto"}`

Adding X-Forwarded-* to the skip list prevents a client from forging their apparent origin.
The proxy should append its own X-Forwarded-For if needed.

### Response direction — skip list
Minimum skip set coming back from upstream to client:
`{"transfer-encoding", "connection", "keep-alive", "set-cookie"}`

Forwarding `set-cookie` from the upstream to the client can allow upstream to set cookies
scoped to the proxy's domain — a session fixation / cross-site cookie injection vector.

## Error Responses

Never include raw exception text in API responses. Use a structured approach:
- Development: include `detail` field gated on `DEBUG=true` env var
- Production: return only a static "Upstream error" message; log the detail server-side

## systemd Hardening Template

Minimum recommended directives for a proxy service:
```ini
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/log/mithril-proxy
CapabilityBoundingSet=
AmbientCapabilities=
```

## Stdio Bridge Security

### Subprocess environment isolation
Never pass `os.environ` wholesale to subprocesses. Build a minimal allowlist env:
```python
_SAFE_ENV_KEYS = {"PATH", "HOME", "USER", "LOGNAME", "LANG", "LC_ALL", "TMPDIR", "TEMP"}
safe_env = {k: v for k, v in os.environ.items() if k in _SAFE_ENV_KEYS}
env = {**safe_env, **extra_env}
```
This prevents dotenv-loaded secrets (DATABASE_URL, AWS_SECRET_ACCESS_KEY, etc.) from
leaking into subprocess environments and potentially into subprocess logs.

### Max-connections cap for subprocess spawning
Without a cap, each SSE connection spawns a new process. Implement per-destination caps:
```python
_dest_semaphores: dict[str, asyncio.Semaphore] = {}
MAX_STDIO_CONNECTIONS_PER_DEST = 10

def _get_dest_semaphore(destination: str) -> asyncio.Semaphore:
    if destination not in _dest_semaphores:
        _dest_semaphores[destination] = asyncio.Semaphore(MAX_STDIO_CONNECTIONS_PER_DEST)
    return _dest_semaphores[destination]
```
Reject new connections (503) if the semaphore cannot be acquired immediately.

### Command string allowlisting
`shlex.split` on a YAML-controlled command string is not shell injection, but it does
allow operators (or compromised CI) to pass any binary and arguments to execv. Apply
a strict allowlist on the executable basename:
```python
ALLOWED_EXECUTABLES = {"npx", "node", "python3", "uvx", "uv"}
executable = Path(shlex.split(command)[0]).name
if executable not in ALLOWED_EXECUTABLES:
    raise ValueError(f"Executable '{executable}' not in allowlist")
```
Also reject commands containing shell metacharacters as a defence-in-depth measure:
```python
import re
_SHELL_META = re.compile(r'[;&|`$<>()\n\r]')
if _SHELL_META.search(command):
    raise ValueError("Shell metacharacters detected in command")
```

### Session ownership in stdio bridge
UUIDs generated by the proxy (bridge.py) are sent to the client in the SSE endpoint
event. They are not secret. Any client that observes or guesses the UUID can POST to
that session's stdin queue. Bind sessions to originating IP at registration time and
reject mismatches in handle_stdio_message.

## install.sh Principle of Least Privilege

The service user should NOT own its own virtualenv or source tree. Recommended layout:
- Source + venv: owned by `root:mithril`, mode `750` (root writes, mithril reads/executes)
- Log dir: owned by `mithril:mithril`, mode `700`
- Config dir: owned by `root:mithril`, mode `750`; individual files mode `640`

This prevents a compromised `mithril` process from modifying its own Python packages
as a persistence mechanism.
